\begingroup %{
	{\setlength\arraycolsep{2pt}
\section{トークナイザー}\label{s1:トークナイザー} %{
\subsection{出発点}\label{s2:出発点} %{
	BNFで与えられた文脈自由文法にしたがってトークン分割するトークナイザーを
	作ることを考える。BNFは次のように'文'と'単語'と'文字'が明示的に
	分割されているものとする。
	\begin{equation*}\begin{split}
		B &= U (b B)^* \\
		U &= V + g_1 B g_2 \\
		V:\omega &= v_1 v_2^* \\
		v_1:\alpha &= '\text{a}' .. '\text{z}' + '\text{A}' .. '\text{Z}' \\
		v_2:\alpha &= v_1 + '\text{0}' .. '\text{9}' \\
		g_1:\alpha &= '(' \\
		g_2:\alpha &= ')' \\
		b:\alpha &= '*' \\
	\end{split}\end{equation*}
	この例では、単語を表す変数にはサフィックス$\omega$、文字を表す変数には
	サフィックス$\alpha$を付けて、単語と文字を明示している。そして、
	\begin{itemize}\setlength{\itemsep}{-1mm} %{
		\item 文変数は、文変数と単語変数と文字変数の文脈自由表現、
		\item 単語変数は、単語変数と文字変数の正規表現、
		\item 文字変数は、文字変数と文字の集合演算
	\end{itemize} %}
	で書かれているものとする。\footnote{
		単語変数は、文字の正規表現で書かれていることになる。したがって、
		文字変数を考える必要はなく、文変数と単語変数の文脈自由表現で定義された
		文変数と文字の正規表現で定義された単語変数だけを考えればよい。
	}
	また、文変数の定義式の右辺に現れる文変数を$0$とすると、単語変数と文字変数
	の多項式となるが、その多項式は'0'にならないとする。例えば、次のようになる
	ことを仮定する。
	\begin{equation*}\begin{split}
		B_0 = U_0,\quad U_0 = V \neq 0 \\
	\end{split}\end{equation*}
	この条件が満たされていないと、文の定義式の中に有限長の入力文字列とは
	決してマッチしない無限長の文字列が現れてしまう。例えば、次のように場合で
	ある。
	\begin{equation*}\begin{split}
		X &= bXb = bb\cdots \\
	\end{split}\end{equation*}
	頭出しの問題は後で考えることにする。
	\begin{equation*}\begin{array}{rcll}
		B &=& U (b B)^* & \quad\text{左頭出し可能} \\
		&=& U + B b B & \quad\text{左頭出し不可能な項を含む} \\
	\end{array}\end{equation*}
	頭出しの問題は原理的な問題ではなく、計算の効率性の問題と思う。

	トークナイザーは
	\begin{itemize}\setlength{\itemsep}{-1mm} %{
		\item 文変数に対して、文の始まりと終わりを、
		\item 単語変数に対して、マッチした単語を
	\end{itemize} %}
	クライアントに知らせるものとする。

	BNFは左結合として解釈することにする。例えば、トークナイザーは
	$g_1Bg_2$という式を$(g_1B)g_2$と解釈する。また、変数の参照は
	変数の定義式をまとめてグループ化する。例えば、トークナイザーは
	$B=U(bB)^*$という式を$B=(U+BbB)(bB)^*$と解釈する。
	BNF内で用いられている積の記号は、トークナイザーでは自由モノイドの積では
	なく結合的でない二項演算として解釈される。トークン分割ではなく、
	単にマッチングするかどうかしか興味がない場合は、BNF内で用いられている積
	の記号を自由モノイドの積として解釈して問題ないが、トークン分割を目的
	とする場合は、自由モノイドの積として解釈することはできない。
%s2:出発点}
\subsection{正規表現でのトークン分解}\label{s2:正規表現でのトークン分解} %{
	次のBNFで与えられた文法にしたがってトークン分割することを考える。
	\begin{equation*}\begin{split}
		E &= A_2A_1B + A_1A_2C \\
		A_1:\omega &= 'a' \\
		A_2:\omega &= A_1^2 \\
		B:\omega &= 'b' \\
		C:\omega &= 'c' \\
	\end{split}\end{equation*}
	この文法の場合、入力文字列の最後まで読み込まないとトークン分割できない。
	これはLL(2)文法となる。通常、LLやLR文法は文脈自由言語の部分言語を定義する
	文法であると説明されているが、トークン分割を目的とする場合は、
	有理言語に対してもトークンの先読みが必要なる。\footnote{
		LLやLR文法について説明されるとき、バックトラック云々という言葉が出てくる
		が、バックトラックとは、読み込んだ入力と進めた状態遷移をあるところまで
		戻して、入力の読み込みと状態の遷移をやり直すことを言う。例の場合では、
		$'a^3c\tau'$という入力文字列に対して、まず、$A_2A_1B$のパターンを
		試してみて、文字$'c'$を読み込んだときにマッチしないことがわかったら、
		初期状態に戻してから$A_1A_2C$のパターンを試すという方法をバックトラック
		という。
	} \footnote{
		この意味では、LLやLR文法という分類の仕方よりも、マッチングやトークン分割
		などの操作を、入力文字列から出力への写像として分類した方が良さそうに
		思う。例えば、マッチングは入力文字列からブーリアンへの写像、トークン分割
		は入力文字列から変数を文字とする文字列への写像として分類できる。
		すると、マッチングは可換代数への写像、トークン分割は（一般には）
		非可換代数への写像として特徴づけられる。可換代数への写像の場合、
		写像空間も可換代数になるので、先読みが必要なくなり、非可換代数への
		写像の場合、写像空間も非可換代数になるので、先読みが必要になる。
	}
%s2:正規表現でのトークン分解}
%s1:トークナイザー}
}\endgroup %}
