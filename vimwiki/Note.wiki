= ノート =

== 大小関係 ==
プログラムを書くとき、場合分けの列挙ができなくて時間を潰すことが多い。
場合分けを代数的に列挙することを考える。
手始めに、大小関係の場合分けを考えてみる。

整数の大小関係を考える。大小関係の推移性は拘束条件のように働く。
例えば、 三つの整数の間の大小関係を独立に 定めることができない。
(a,b,c):Z^3^として、(a,b)と(b,c)の関係を与えた時に、(a,b)の取りうる関係を見てみる。
||  || b<=c || c<b || 
|| a<=b || a<=b<=c || all || 
|| b<a || all || c<a || 
ここで、allは何も定まらないことを表すものとする。
この表の場合は、allはa<=cまたはc<aを表す。
三値関係{<,=,>}の場合も見てみる。
||  || b=c || b<c || c<b ||
|| a=b || a=c || a<c || c<a ||
|| a<b || a<c || a<c || all || 
|| b<a || c<a || all || c<a ||
これらの表を行列としてみると、二値関係の場合も、三値関係の場合も、
	* 対称行列であり、
	* 行の和はallになり、
	* 列の和はallになり、
	* 対角成分の和はallになる、
ということが見て取れる。
行列の対称性は、論理積の対称性({{{x and y = y and x}}}) 
と大小関係の反射性({{{a<=b and b<=a iff a=b}}})からの帰結なのだろう。

ソートをする関数を考えてみる。
長さ２と長さ３の単語に対するソートは、次のように書けるだろう。
{{{
sort:(a:Z, b:Z) -> (Z, Z) = {
	code = {
		if a <= b { 
			return (a, b);
		} 
		return (b, a);
	}
}
sort:(a:Z, b:Z, c:Z) -> (Z, Z, Z) = {
	local:(x:Z, y:Z) -> (Z, Z, Z) = {
		if y <= c {
			return (x, y, c);
		} else x <= c {
			return (x, c, y);
		}
		return (c, x, y);
	}
	code = {
		if a <= b {
			return local(a, b);
		}
		return local(b, a);
	}
}
}}}
このコードを眺めると代数構造が見えてくる。
FZをZを文字とする単語の集合、単語の連結をmとする。
単語を文字を使って明示的に書くときには、括弧を使って{{{[abc]}}}というように
書くことにする。mの単位元を[]と書くことにする。
