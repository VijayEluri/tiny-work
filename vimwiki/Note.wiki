= ノート =

freemind 配置

== Scale-space ==
||スケール ||人間の見るもの || ||
||km ||森 || ||
||m ||木 || ||
||cm ||葉 || ||

scale-space theoryを日本語に訳すと、'解像度に注目した話'というのが
適当な気がする。 直訳すると尺度空間だが、現在使われている処方はを省みると、
尺度とは解像度のことで、空間とは詳細度を変更するパラメータ空間のことになっている。
結局のところ、scale-space theoryとは、近似のための理論ではないだろうか。
工学的には、観測データに入っている雑音を除去するための平滑化は、
通常の感覚での近似ではない。
見方を変えて、観測データを厳密解と思ってしまうと、平滑化は近似になるだろう。
この見方の場合は、厳密解へ近づいていくことが重要ではなくて、
近似精度を荒くしていくことが重要になる。
時には、厳密解より近似解の方が重要になることがある。

詳細化では、より早く厳密解に近づくことが重要になる。
疎視化の価値は何によって定まるのだろうか。
離散化の場合には、離散化する方法は無数にあるので、離散化したときに保存する性質が重要になる。
例えば、ソリトンの離散化では、孤立波の性質が保存することが重要になる。
疎視化の場合にも、保存する性質によって、疎視化の特徴づけができればよいと思う。

7/9 13:00
7/14 休み
7/24 10:00
7/30 13:00
8/5 10:00

== シミュレーションの使い方 ==
	* シミュレーションを使って計画を立てると実施後に証拠が残る
	* 証拠が残るから計画立案の改良が可能
	* いいこと尽くめに見えるが、あまり使われていないのは何故？
		* 客観的にモデルを設定することが難しい（皮算用と言われるものの類）
		* 知らないだけで、多くの製造現場で使われている
		* ヒット商品を作り出す手法ではないため、地味な存在

== リー群の測度 ==
||名前 ||複素次元 ||体積 ||日本語 ||
||GL_n ||n^2 || ||一般線形群 ||
||SL_n ||n^2-1 || ||特殊線形群 ||
||SU_n ||n^2-1 ||コンパクト ||特殊ユニタリ群 ||
||SO_n ||n(n-1)/2 ||コンパクト ||特殊直交群 ||
||Sp_2n ||n(2n+1) || ||斜交群 ||

== 傾きの検出 ==
既知の事実として、ガウシアンのラプラシアンによって傾いている場所が検出できる。 
以下のは、ガウシアンのラプラシアンをプロットするRコードである。 Rコンソールにペーストすれば、プロットが表示される。
{{{
gaussian <- function(t, x) {
	(2*pi*t)^(1/2)*exp(-x^2/t/2);
}

dx1.gaussian <- function(t, x) {
	-(2*pi*t)^(1/2)*x/t*exp(-x^2/t/2);
}

dx2.gaussian <- function(t, x) {
	(2*pi*t)^(1/2)*((x/t)^2-1/t)*exp(-x^2/t/2);
}

dx.gaussian <- dx1.gaussian 

test.gaussian <- function() {
	old.par <- par(mfrow=c(2,3));
	on.exit(par(old.par));
	xs <- (-200:200) / 20;
	t <- 1;
	plot(xs, gaussian(t, xs), type="l");
	plot(xs, dx1.gaussian(t, xs), type="l");
	plot(xs, dx2.gaussian(t, xs), type="l");
	#plot(xs, gaussian(t, 0) + (1/2)*xs^2*dx2.gaussian(t, 0), type="l");
	t <- 10;
	plot(xs, gaussian(t, xs), type="l");
	plot(xs, dx1.gaussian(t, xs), type="l");
	plot(xs, dx2.gaussian(t, xs), type="l");
	#plot(xs, gaussian(t, 0) + (1/2)*xs^2*dx2.gaussian(t, 0), type="l");
}

if (T) {
	test.gaussian();
}
}}}
ラプラシアンによって、傾いている場所が検出できることをより直感的に理解したい。
どのように考えればよいのだろうか？

== 畳み込み ==
現実の世界の中で、畳み込みはどのように利用されているのだろうか。

=== 例 ===
1からnまでの集合をN_nとする。N_nの中からランダムに２つ選び出す。
選び出された２つの数の和がkになる確率は
{{{
	\sum_{i=1}^n p(i)p(k-i)
}}}
となる。ここで、p(k)は数字kを選び出す確率である。これは畳み込みp@p
になっている。これを代数として解釈するには、余積で考えた方がよさそうだ。
足してkになるN_nの数字の数字の組は
{{{
	delta: N_n -> (N_n, N_n)
	k |-> \sum_{i=1}^n (i, k-i)
}}}
で与えられる。確率pは写像p:N_n->Rで与えられる。可換図
{{{
	N_n -delta-> (N_n, N_n) -(p,q)-> (R,R) -*-> R
	N_n -p@q-> R
}}}
が成り立つように確率空間に積@が定義できる。毎度おなじみのパターンである。

== 定数畳み込み ==
関数空間の積ではなくて、コンパイラの最適化手法の一つ。
今問題にしている畳み込みとは関係ないが、同じ畳み込みという単語を使っているので、
後学のために記録しておく。

プログラミングコードで、次のような定数式が与えられたとき、
コンパイル時に計算を済ませておいて、プログラムの実行速度を上げる手法である。
{{{
	long value = 1 + 2 + 3 + 4;
}}}

=== 定数伝播 ===
Wikipediaの例
{{{
	int x = 14;
	int y = 7 - x / 2;
	return y * (28 / x + 2);
}}}
xのインライン化
{{{
	int x = 14;
	int y = 7 - 14 / 2;
	return y * (28 / 14 + 2);
}}}
xの消去
{{{
	int y = 7 - 14 / 2;
	return y * (28 / 14 + 2);
}}}
yのインライン化と消去
{{{
}}}
これを代数式で書いてみる。
{{{
	set: (Variable, Expression) -> Variable
	plus,minus,multiplis,divides: (Expression, Expression) -> Expression

	node1 = set (x, 14)
	node2 = set (1, minus) (1, 1, divides) (y, 7, node1, 2)
	node3 = multipies (1, plus) (1, divides, 1) (node2, 28, node1, 2)
}}}

== 数式の書き方 ==
演算子は前置き式で書くのと中置き式で書くのではどちらが便利か。
ここで、書きやすく、読みやすい記述方法を便利な記述方法とする。
代数構造を探しているときは、写像の合成を多用するので、前置き式が便利である。
実際に計算するときは、
	* 結合的な二項演算で、
	* 演算の結合順序を覚えている
ものに対しては、中置き式の方が便利である。
一方、写像の合成とカリー化を多用する場合は、前置き式の方が便利である。
現在のことろ、一長一短で、状況によって使い分けている。

== 大小関係 ==
プログラムを書くとき、場合分けの列挙ができなくて時間を潰すことが多い。
場合分けを代数的に列挙することを考える。
手始めに、大小関係の場合分けを考えてみる。
整数の大小関係を考える。大小関係の推移性と反射性は拘束条件のように働く。
三つの変数の真ん中の値を求める関数は次のようになる。
{{{
midian:(a:Z, b:Z, c:Z) -> Z = {
	code = {
		if a <= b {
			if b <= c {
				return b;
			} else c <= a {
				return a;
			}
			return c;
		}
		if a <= c {
			return a;
		} else c <= b {
			return b;
		}
		return c;
	}
}
}}}
このコードの正しいことの証明は次の表に拠る。
||条件 ||ソートされた単語 ||
||a<=b & b<=c ||abc ||
||a<=b & (1-b<=c) & c<=a ||cab ||
||a<=b & (1-b<=c) & (1-c<=a) ||acb ||
||(1-a<=b) & a<=c ||bac ||
||(1-a<=b) & (1-a<=c) & c<=b ||cba ||
||(1-a<=b) & (1-a<=c) & (1-c<=b) ||bca ||
条件式と単語を対応させて、計算を簡単にすることを考えてみる。

単語から条件式への写像を{{{f:FZ -> B}}}を次のように定義する。

シャッフル積{{{s:(Z,Z)->Z}}}を考える。
シャッフル積は順序付けされた点の並びを列挙する。
例えば、ソート済みに２つの単語、abとc、が与えら時、(a,b,c)を文字とする
ソート済みの単語の列挙は、次のシャッフル積で与えられる。
{{{[ab].s[c]=[abc]+[acb]+[cab]}}}
また、ライプニッツ則が成り立つ。
{{{[a].s(x.m y)=([a].s x).m y + x.m ([a].s y)}}}
	* シャッフル積のライプニッツ則が冪等半環を係数とする場合だけかは不明

== バックアップ ==
整数の大小関係を考える。大小関係の推移性は拘束条件のように働く。
例えば、 三つの整数の間の大小関係を独立に 定めることができない。
(a,b,c):Z^3^として、(a,b)と(b,c)の関係を与えた時に、(a,b)の取りうる関係を見てみる。
||  || b<=c || c<b || 
|| a<=b || a<=b<=c || all || 
|| b<a || all || c<a || 
ここで、allは何も定まらないことを表すものとする。
この表の場合は、allはa<=cまたはc<aを表す。
三値関係{<,=,>}の場合も見てみる。
||  || b=c || b<c || c<b ||
|| a=b || a=c || a<c || c<a ||
|| a<b || a<c || a<c || all || 
|| b<a || c<a || all || c<a ||
これらの表を行列としてみると、二値関係の場合も、三値関係の場合も、
	* 対称行列であり、
	* 行の和はallになり、
	* 列の和はallになり、
	* 対角成分の和はallになる、
ということが見て取れる。
行列の対称性は、論理積の対称性({{{x and y = y and x}}}) 
と大小関係の反射性({{{a<=b and b<=a iff a=b}}})からの帰結なのだろう。

